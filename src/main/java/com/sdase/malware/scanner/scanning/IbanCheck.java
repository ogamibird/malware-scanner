package com.sdase.malware.scanner.scanning;

import com.sdase.malware.scanner.dao.IbanBlacklistRepo;
import com.sdase.malware.scanner.exception.FileDataExtractionException;
import com.sdase.malware.scanner.io.FileDataExtractionService;
import com.sdase.malware.scanner.model.CheckResult;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;
import org.springframework.util.MimeType;

import java.util.List;
import java.util.Set;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@Component
@AllArgsConstructor
public class IbanCheck implements MalwareCheck {

    /* List of regex patterns for extracting the IBANS. The regexes are taken
    from the following page: http://ht5ifv.serprest.pt/extensions/tools/IBAN/index.html
    The ground truth of the website is rather outdated, so some countries are missing in the below list. A potenital improvement
    could be to dynamicly get the IBAN-formats from the swift-registry (https://www.swift.com/swift-resource/11971/download)
    parsing the file and creating the regex patterns in a sheduled task and storing them in the database.
     */
    private static final List<String> IBAN_EXTRACTION_REGEXES = List.of(
            "AL\\d{10}[0-9A-Z]{16}",
            "AD\\d{10}[0-9A-Z]{12}",
            "AT\\d{18}",
            "AZ\\d{2}[A-Z]{4}[0-9A-Z]{20}",
            "BH\\d{2}[A-Z]{4}[0-9A-Z]{14}",
            "BE\\d{14}",
            "BA\\d{18}",
            "BG\\d{2}[A-Z]{4}\\d{6}[0-9A-Z]{8}",
            "HR\\d{19}",
            "CY\\d{10}[0-9A-Z]{16}",
            "CZ\\d{22}",
            "DK\\d{16}",
            "FO\\d{16}",
            "GL\\d{16}",
            "DO\\d{2}[0-9A-Z]{4}\\d{20}",
            "EE\\d{18}",
            "FI\\d{16}",
            "FR\\d{12}[0-9A-Z]{11}\\d{2}",
            "GE\\d{2}[A-Z]{2}\\d{16}",
            "DE\\d{20}",
            "GI\\d{2}[A-Z]{4}[0-9A-Z]{15}",
            "GR\\d{9}[0-9A-Z]{16}",
            "HU\\d{26}",
            "IS\\d{24}",
            "IE\\d{2}[A-Z]{4}\\d{14}",
            "IL\\d{21}",
            "IT\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}",
            "KZ{2}\\d{5}[0-9A-Z]{13}",
            "KW\\d{2}[A-Z]{4}22!",
            "LV\\d{2}[A-Z]{4}[0-9A-Z]{13}",
            "LB\\d{6}[0-9A-Z]{20}",
            "LI\\d{7}[0-9A-Z]{12}",
            "LT\\d{18}",
            "LU\\d{5}[0-9A-Z]{13}",
            "MK\\d{5}[0-9A-Z]{10}\\d{2}",
            "MT\\d{2}[A-Z]{4}\\d{5}[0-9A-Z]{18}",
            "MR13\\d{23}",
            "MU\\d{2}[A-Z]{4}\\d{19}[A-Z]{3}",
            "MC\\d{12}[0-9A-Z]{11}\\d{2}",
            "ME\\d{20}",
            "NL\\d{2}[A-Z]{4}\\d{10}",
            "NO\\d{13}",
            "PL\\d{10}[0-9A-Z]{16}",
            "PT\\d{23}",
            "RO\\d{2}[A-Z]{4}[0-9A-Z]{16}",
            "SM\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}",
            "SA\\d{4}[0-9A-Z]{18}",
            "RS\\d{20}",
            "SK\\d{22}",
            "SI\\d{17}",
            "ES\\d{22}",
            "SE\\d{22}",
            "CH\\d{7}[0-9A-Z]{12}",
            "TN59\\d{20}",
            "TR\\d{7}[0-9A-Z]{17}",
            "AE\\d{21}",
            "GB\\d{2}[A-Z]{4}\\d{14}"
    );

    private static final List<Pattern> IBAN_EXTRATION_PATTERN = IBAN_EXTRACTION_REGEXES.stream()
                                                                                       .map(Pattern::compile)
                                                                                       .toList();

    private final FileDataExtractionService extractionService;
    private final IbanBlacklistRepo ibanBlacklistRepo;

    @Override
    public int getPriority() {
        return 8;
    }

    @Override
    public boolean abortOnSuspicionFound() {
        return false;
    }

    @Override
    public String getName() {
        return "Iban-Check";
    }

    @Override
    public CheckResult check(Resource resource, MimeType type) {
        String fileData;
        try {
            /*
            The extraction of the data from the file is hidden behind a facade. So different
            filetypes and kind of documents can be checked.
             */
            fileData = extractionService.extractData(resource, type);
        } catch (FileDataExtractionException e) {
            String message = "Failure during document check. %s".formatted(e.getMessage());
            log.error(message);
            return resultError(message.formatted(e.getMessage()));
        }

        Set<String> extractedIbans = extractIbansFromText(fileData);
        /*
        The iban checksum is not validated becaus it is assumed that only valid
        ibans are in the blacklist.
         */
        Set<String> matchedBlacklistedIbans = ibanBlacklistRepo.findAllByIbans(extractedIbans);
        return matchedBlacklistedIbans.isEmpty() ? resultOk() : resultSuspicion(matchedBlacklistedIbans);
    }

    private static Set<String> extractIbansFromText(String text) {
        return IBAN_EXTRATION_PATTERN.stream()
                                     .parallel()
                                     .map(p -> p.matcher(text))
                                     .flatMap(Matcher::results)
                                     .map(MatchResult::group)
                                     .collect(Collectors.toSet());
    }

    private CheckResult resultSuspicion(Set<String> matchedBlacklistedIbans) {
        return CheckResult.builder()
                          .state(CheckResult.State.SUSPICIOUS)
                          .details("The following blacklisted IBANS where found in the document: %s".formatted(String.join(", ", matchedBlacklistedIbans)))
                          .checkName(getName())
                          .build();
    }

    private CheckResult resultOk() {
        return CheckResult.builder()
                          .state(CheckResult.State.OK)
                          .checkName(getName())
                          .build();
    }

    private CheckResult resultError(String reason) {
        return CheckResult.builder().state(CheckResult.State.ERROR)
                          .details(reason)
                          .checkName(getName())
                          .build();
    }
}
