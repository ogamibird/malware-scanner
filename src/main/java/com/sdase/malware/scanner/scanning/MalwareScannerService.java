package com.sdase.malware.scanner.scanning;

import com.sdase.malware.scanner.exception.FileDownloadException;
import com.sdase.malware.scanner.io.FileDownloadService;
import com.sdase.malware.scanner.model.CheckRequest;
import com.sdase.malware.scanner.model.CheckResult;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.springframework.util.InvalidMimeTypeException;
import org.springframework.util.MimeType;
import org.springframework.util.MimeTypeUtils;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

@Slf4j
@Service
public class MalwareScannerService {

    private final List<MalwareCheck> checks;
    private final FileDownloadService fileDownloadService;

    public MalwareScannerService(List<MalwareCheck> checks, FileDownloadService fileDownloadService) {
        /*
         The autowired MalwareChecks are sorted by their priority. Ensures that the checks are performed in the correct
         order.
         */
        this.checks = checks.stream()
                            .sorted(Comparator.comparingInt(MalwareCheck::getPriority))
                            .toList();
        this.fileDownloadService = fileDownloadService;
    }

    public List<CheckResult> scanFile(CheckRequest checkRequest) {
        log.debug("Starting file scan for: {}", checkRequest);
        MimeType mimeType;
        try {
            mimeType = MimeTypeUtils.parseMimeType(checkRequest.getFileType());
        } catch (InvalidMimeTypeException e) {
            String message = "Type %s could not be parsed into a valid MimeType. Type undefined.";
            log.error(message, e);
            CheckResult result = CheckResult.builder()
                                            .state(CheckResult.State.ERROR)
                                            .checkName("Setup")
                                            .details(message)
                                            .build();
            return List.of(result);
        }

        Resource document;
        try {
            /* A possible improvement would be to change the structure a little bit so that some scans can be
            performed before the file is actually dowloaded. For example a check if the domain in the url
            is blacklisted or malicious would be a good idea to perform before downloading the file.
             */
            document = fileDownloadService.downloadFile(checkRequest.getUrl());
        } catch (FileDownloadException e) {
            log.error("Failed to download file from: {}", checkRequest.getUrl(), e);
            CheckResult result = CheckResult.builder()
                                            .state(CheckResult.State.ERROR)
                                            .checkName("Setup")
                                            .details("Checking of document failed due to error during download of the document. Reason: %s".formatted(e.getMessage()))
                                            .build();
            return List.of(result);
        }
        List<CheckResult> checkResults = scanFileInternal(document, mimeType);
        log.debug("File scan complete for: {}", checkRequest);
        return checkResults;
    }

    private List<CheckResult> scanFileInternal(Resource resource, MimeType mimeType) {
        boolean aborted = false;
        List<CheckResult> checkResults = new ArrayList<>();
        for (MalwareCheck check : checks) {
            /* Makes it possible to abort subsequent checks if an earlier check found something suspicious and deems it
            a bad idea to run subsequent checks. For example if a virus check finds something suspicious subsequent
            checks that open the file should best not run.
             */
            if (aborted) {
                CheckResult result = CheckResult.builder()
                                                .state(CheckResult.State.IGNORED)
                                                .checkName(check.getName())
                                                .details("Check skipped because of finding in earlier check.")
                                                .build();
                checkResults.add(result);
            } else {
                CheckResult checkResult = check.check(resource, mimeType);
                if (CheckResult.State.SUSPICIOUS.equals(checkResult.getState()) && check.abortOnSuspicionFound()) {
                    aborted = true;
                }
                checkResults.add(checkResult);
            }
        }
        return checkResults;
    }
}